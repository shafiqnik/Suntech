<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Suntech Message Parser</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        .status {
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .status.connected {
            background: #d4edda;
            color: #155724;
        }
        
        .message-container {
            margin-bottom: 30px;
        }
        
        .message-header {
            background: #667eea;
            color: white;
            padding: 15px;
            border-radius: 5px 5px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .message-type {
            font-weight: bold;
            font-size: 1.2em;
        }
        
        .message-timestamp {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            margin-bottom: 20px;
        }
        
        th {
            background: #f8f9fa;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #dee2e6;
        }
        
        td {
            padding: 10px 12px;
            border-bottom: 1px solid #dee2e6;
            color: #555;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
        
        .nested-table {
            margin: 10px 0;
        }
        
        .nested-table th {
            background: #e9ecef;
            font-size: 0.9em;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .no-messages {
            text-align: center;
            padding: 40px;
            color: #999;
            font-size: 1.2em;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 0.85em;
            font-weight: 600;
        }
        
        .badge-stt {
            background: #28a745;
            color: white;
        }
        
        .badge-bda {
            background: #17a2b8;
            color: white;
        }
        
        .badge-error {
            background: #dc3545;
            color: white;
        }
        
        .raw-data-container {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .raw-data-hex {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            word-break: break-all;
            white-space: pre-wrap;
            background: #ffffff;
            padding: 10px;
            border-radius: 3px;
            border: 1px solid #dee2e6;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .highlight-vecima {
            border: 3px solid #28a745;
            background: #f0fff4 !important;
        }
        
        .highlight-vecima .message-header {
            background: #28a745 !important;
            font-weight: bold;
        }
        
        .highlight-vecima .message-type,
        .highlight-vecima .message-timestamp,
        .highlight-vecima table,
        .highlight-vecima td,
        .highlight-vecima th,
        .highlight-vecima h3 {
            color: #155724 !important;
            font-weight: bold !important;
        }
        
        .highlight-vecima .badge {
            background: #155724 !important;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîå Suntech Message Parser</h1>
        <p class="subtitle">Real-time monitoring of ST6560 device messages on port 18160</p>
        
        <div class="controls">
            <button onclick="refreshMessages()">üîÑ Refresh</button>
            <button onclick="clearMessages()">üóëÔ∏è Clear</button>
            <span class="status" id="status">Loading...</span>
        </div>
        
        <div id="messages-container">
            <div class="no-messages">No messages received yet. Waiting for data...</div>
        </div>
    </div>
    
    <script>
        let messages = [];
        let autoRefresh = true;
        
        async function fetchMessages() {
            try {
                const response = await fetch('/api/messages');
                const data = await response.json();
                messages = data;
                updateStatus('connected', `Connected - ${messages.length} message(s) received`);
                renderMessages();
            } catch (error) {
                updateStatus('error', 'Error fetching messages: ' + error.message);
            }
        }
        
        function updateStatus(type, message) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
        }
        
        function containsKeywords(msg) {
            // Check if message has target MAC addresses (from parsed sensors)
            if (msg.has_target_mac === true) {
                return true;
            }
            
            // Check parsed sensors for target MAC addresses
            if (msg.sensors && Array.isArray(msg.sensors)) {
                for (const sensor of msg.sensors) {
                    if (sensor.is_target_mac === true) {
                        return true;
                    }
                    // Also check MAC address strings
                    if (sensor.mac_address_raw) {
                        const macUpper = sensor.mac_address_raw.toUpperCase();
                        if (macUpper.startsWith('AC233F') || macUpper.startsWith('C30000')) {
                            return true;
                        }
                    }
                    if (sensor.mac_address) {
                        const macUpper = sensor.mac_address.toUpperCase();
                        if (macUpper.startsWith('AC:23:3F') || macUpper.startsWith('C3:00:00')) {
                            return true;
                        }
                    }
                }
            }
            
            // Keywords to search for (case-insensitive)
            const keywords = ['Vecima', 'AC233F', 'C3000', 'AC:23:3F', 'C3:00:00'];
            
            // Check raw_data if available (hex string)
            if (msg.raw_data) {
                const rawDataUpper = msg.raw_data.toUpperCase();
                
                // Check for hex patterns directly
                // AC233F in hex = AC 23 3F (without colons)
                // C30000 in hex = C3 00 00 (without colons)
                const hexPatterns = ['AC233F', 'AC23', 'C30000', 'C3000', 'C300'];
                for (const pattern of hexPatterns) {
                    if (rawDataUpper.includes(pattern.toUpperCase())) {
                        return true;
                    }
                }
                
                // Try to decode hex to ASCII to find text strings
                try {
                    // Convert hex string to bytes and then to ASCII where possible
                    let asciiStr = '';
                    for (let i = 0; i < rawDataUpper.length; i += 2) {
                        const hexByte = rawDataUpper.substr(i, 2);
                        const byteValue = parseInt(hexByte, 16);
                        // Only include printable ASCII characters
                        if (byteValue >= 32 && byteValue <= 126) {
                            asciiStr += String.fromCharCode(byteValue);
                        } else {
                            asciiStr += ' ';
                        }
                    }
                    const asciiUpper = asciiStr.toUpperCase();
                    if (asciiUpper.includes('VECIMA')) {
                        return true;
                    }
                } catch (e) {
                    // Ignore decoding errors
                }
            }
            
            // Check if message contains Vecima in any string field
            const msgStr = JSON.stringify(msg).toUpperCase();
            if (msgStr.includes('VECIMA')) {
                return true;
            }
            
            return false;
        }
        
        function renderMessages() {
            const container = document.getElementById('messages-container');
            
            if (messages.length === 0) {
                container.innerHTML = '<div class="no-messages">No messages received yet. Waiting for data...</div>';
                return;
            }
            
            // Reverse to show newest first
            const reversedMessages = [...messages].reverse();
            
            container.innerHTML = reversedMessages.map((msg, index) => {
                if (msg.error) {
                    return `
                        <div class="message-container">
                            <div class="error">
                                <strong>Error:</strong> ${msg.error}
                                ${msg.raw_data ? `<br><small>Raw: ${msg.raw_data.substring(0, 100)}...</small>` : ''}
                            </div>
                            <div class="message-timestamp">${formatTimestamp(msg.timestamp)}</div>
                        </div>
                    `;
                }
                
                const reportType = msg.report_type || 'Unknown';
                const badgeClass = reportType.includes('STT') ? 'badge-stt' : 
                                 reportType.includes('BDA') ? 'badge-bda' : 'badge-error';
                
                // Check if message contains Vecima or related keywords
                const hasKeywords = containsKeywords(msg);
                const highlightClass = hasKeywords ? 'highlight-vecima' : '';
                
                let content = '';
                
                if (reportType.includes('STT')) {
                    content = renderSTTMessage(msg);
                } else if (reportType.includes('BDA')) {
                    content = renderBDAMessage(msg);
                } else {
                    content = renderGenericMessage(msg);
                }
                
                return `
                    <div class="message-container ${highlightClass}">
                        <div class="message-header">
                            <span class="message-type">
                                <span class="badge ${badgeClass}">${reportType}</span>
                                ${hasKeywords ? ' <span style="color: #fff; font-weight: bold;">üîç Vecima/AC233F Detected</span>' : ''}
                            </span>
                            <span class="message-timestamp">${formatTimestamp(msg.timestamp)}</span>
                        </div>
                        ${content}
                    </div>
                `;
            }).join('');
        }
        
        function renderSTTMessage(msg) {
            return `
                <table>
                    <tr><th>Field</th><th>Value</th></tr>
                    <tr><td>Device ID (ESN)</td><td>${msg.device_id_esn || 'N/A'}</td></tr>
                    <tr><td>Packet Length</td><td>${msg.packet_length || 'N/A'}</td></tr>
                    <tr><td>Model ID</td><td>${msg.model_id || 'N/A'}</td></tr>
                    <tr><td>Software Version</td><td>${msg.software_version || 'N/A'}</td></tr>
                    <tr><td>Message Type</td><td>${msg.message_type || 'N/A'}</td></tr>
                    <tr><td>GPS Timestamp</td><td>${msg.timestamp_gps || 'N/A'}</td></tr>
                </table>
                
                ${msg.gps ? `
                    <h3>GPS Data</h3>
                    <table class="nested-table">
                        <tr><th>Field</th><th>Value</th></tr>
                        <tr><td>Latitude</td><td>${msg.gps.latitude}</td></tr>
                        <tr><td>Longitude</td><td>${msg.gps.longitude}</td></tr>
                        <tr><td>Speed (km/h)</td><td>${msg.gps.speed_kmh}</td></tr>
                        <tr><td>Course (deg)</td><td>${msg.gps.course_deg}</td></tr>
                        <tr><td>Satellites</td><td>${msg.gps.satellites}</td></tr>
                        <tr><td>Fix Status</td><td>${msg.gps.fix_status}</td></tr>
                    </table>
                ` : ''}
                
                ${msg.cellular ? `
                    <h3>Cellular Data</h3>
                    <table class="nested-table">
                        <tr><th>Field</th><th>Value</th></tr>
                        <tr><td>MCC</td><td>${msg.cellular.mcc}</td></tr>
                        <tr><td>MNC</td><td>${msg.cellular.mnc}</td></tr>
                        <tr><td>LAC</td><td>${msg.cellular.lac}</td></tr>
                        <tr><td>Rx Level (RSSI)</td><td>${msg.cellular.rx_level_rssi}</td></tr>
                        <tr><td>Cell ID</td><td>${msg.cellular.cell_id}</td></tr>
                    </table>
                ` : ''}
                
                ${msg.status ? `
                    <h3>Status</h3>
                    <table class="nested-table">
                        <tr><th>Field</th><th>Value</th></tr>
                        <tr><td>Input State</td><td>${msg.status.input_state_hex}</td></tr>
                        <tr><td>Output State</td><td>${msg.status.output_state_hex}</td></tr>
                        <tr><td>Device Mode</td><td>${msg.status.device_mode}</td></tr>
                        <tr><td>Report Type ID</td><td>${msg.status.report_type_id}</td></tr>
                        <tr><td>Message Number</td><td>${msg.status.message_number}</td></tr>
                    </table>
                ` : ''}
            `;
        }
        
        function renderBDAMessage(msg) {
            let sensorsHtml = '';
            let macAddressesList = [];
            
            if (msg.sensors && Array.isArray(msg.sensors) && msg.sensors.length > 0) {
                // Collect all MAC addresses for summary
                msg.sensors.forEach((sensor, idx) => {
                    const mac = sensor.mac_address || sensor.mac_address_raw || null;
                    if (mac) {
                        macAddressesList.push({
                            index: idx + 1,
                            mac: mac,
                            isTarget: sensor.is_target_mac || false,
                            rssi: sensor.rssi
                        });
                    }
                });
                
                sensorsHtml = `
                    <h3>BLE Sensors (${msg.sensors_parsed || msg.sensors.length} parsed)</h3>
                    <table class="nested-table">
                        <tr>
                            <th>#</th>
                            <th>MAC Address</th>
                            <th>RSSI</th>
                            <th>Data Size</th>
                            <th>Raw Data (first 50 bytes)</th>
                        </tr>
                        ${msg.sensors.map((sensor, idx) => {
                            const macClass = sensor.is_target_mac ? 'style="color: #28a745; font-weight: bold;"' : '';
                            const macDisplay = sensor.mac_address || sensor.mac_address_raw || 'N/A';
                            const macBadge = sensor.is_target_mac ? ' <span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8em;">TARGET</span>' : '';
                            return `
                                <tr>
                                    <td>${idx + 1}</td>
                                    <td ${macClass}><strong>${macDisplay}</strong>${macBadge}</td>
                                    <td>${sensor.rssi !== undefined ? sensor.rssi + ' dBm' : 'N/A'} (${sensor.rssi_hex || 'N/A'})</td>
                                    <td>${sensor.data_size || 'N/A'} bytes</td>
                                    <td><code style="font-size: 0.85em;">${sensor.raw_data ? sensor.raw_data.substring(0, 100) + '...' : 'N/A'}</code></td>
                                </tr>
                            `;
                        }).join('')}
                    </table>
                `;
            } else if (msg.raw_data) {
                // Fallback: try to extract MAC addresses from raw data if sensors weren't parsed
                sensorsHtml = `
                    <h3>BLE Sensors</h3>
                    <p style="color: #dc3545;"><strong>Note:</strong> Sensor data parsing incomplete. Showing raw data.</p>
                    <p><strong>Raw Data (Hex):</strong> <code style="font-size: 0.85em; word-break: break-all;">${msg.raw_data.substring(0, 500)}${msg.raw_data.length > 500 ? '...' : ''}</code></p>
                `;
            }
            
            // Add MAC addresses summary section
            let macSummaryHtml = '';
            if (macAddressesList.length > 0) {
                macSummaryHtml = `
                    <h3>üì° Detected BLE MAC Addresses</h3>
                    <table class="nested-table">
                        <tr>
                            <th>#</th>
                            <th>MAC Address</th>
                            <th>Status</th>
                            <th>RSSI</th>
                        </tr>
                        ${macAddressesList.map((macInfo) => {
                            const macClass = macInfo.isTarget ? 'style="color: #28a745; font-weight: bold; font-size: 1.1em;"' : '';
                            const statusBadge = macInfo.isTarget 
                                ? '<span style="background: #28a745; color: white; padding: 4px 8px; border-radius: 3px; font-weight: bold;">TARGET MAC</span>'
                                : '<span style="background: #6c757d; color: white; padding: 4px 8px; border-radius: 3px;">Standard</span>';
                            return `
                                <tr>
                                    <td>${macInfo.index}</td>
                                    <td ${macClass}><strong>${macInfo.mac}</strong></td>
                                    <td>${statusBadge}</td>
                                    <td>${macInfo.rssi !== undefined ? macInfo.rssi + ' dBm' : 'N/A'}</td>
                                </tr>
                            `;
                        }).join('')}
                    </table>
                `;
            }
            
            return `
                <table>
                    <tr><th>Field</th><th>Value</th></tr>
                    <tr><td>Device ID (ESN)</td><td>${msg.device_id_esn || 'N/A'}</td></tr>
                    <tr><td>Packet Length</td><td>${msg.packet_length || 'N/A'}</td></tr>
                    <tr><td>Model ID</td><td>${msg.model_id || 'N/A'}</td></tr>
                    <tr><td>Software Version</td><td>${msg.software_version || 'N/A'}</td></tr>
                    <tr><td>BLE Scan Status</td><td>${msg.ble_scan_status || 'N/A'}</td></tr>
                    <tr><td>Total Reports Expected</td><td>${msg.total_reports_expected || 'N/A'}</td></tr>
                    <tr><td>Current Report Number</td><td>${msg.current_report_number || 'N/A'}</td></tr>
                    <tr><td>Scanned Sensor Count</td><td>${msg.scanned_sensor_count || 'N/A'}</td></tr>
                    <tr><td>Sensors Parsed</td><td>${msg.sensors_parsed || 0}</td></tr>
                    <tr><td>Has Target MAC</td><td>${msg.has_target_mac ? '<strong style="color: #28a745; font-size: 1.1em;">YES ‚úì</strong>' : 'No'}</td></tr>
                    <tr><td>GPS Timestamp</td><td>${msg.timestamp_gps || 'N/A'}</td></tr>
                </table>
                
                ${msg.location_scan_start ? `
                    <h3>Scan Location</h3>
                    <table class="nested-table">
                        <tr><th>Field</th><th>Value</th></tr>
                        <tr><td>Latitude</td><td>${msg.location_scan_start.latitude}</td></tr>
                        <tr><td>Longitude</td><td>${msg.location_scan_start.longitude}</td></tr>
                    </table>
                ` : ''}
                
                ${macSummaryHtml}
                
                ${sensorsHtml}
                
                ${msg.remaining_payload_bytes !== undefined ? `
                    <p><strong>Remaining Payload:</strong> ${msg.remaining_payload_bytes} bytes</p>
                ` : ''}
                
                ${msg.raw_data ? `
                    <div class="raw-data-container">
                        <h3>üìã Complete Raw Message (Hex)</h3>
                        <p><strong>Total Length:</strong> ${msg.raw_data.length / 2} bytes (${msg.raw_data.length} hex characters)</p>
                        <div class="raw-data-hex">${formatHexData(msg.raw_data)}</div>
                        <p style="margin-top: 10px; font-size: 0.85em; color: #666;">
                            <strong>Copy Format:</strong> <code style="background: #e9ecef; padding: 2px 6px; border-radius: 3px;">${msg.raw_data}</code>
                        </p>
                    </div>
                ` : ''}
            `;
        }
        
        function formatHexData(hexString) {
            // Format hex string with spaces every 2 characters and line breaks every 32 bytes (64 hex chars)
            let formatted = '';
            for (let i = 0; i < hexString.length; i += 2) {
                formatted += hexString.substr(i, 2);
                if ((i + 2) % 64 === 0) {
                    formatted += '\n';
                } else if ((i + 2) % 2 === 0 && (i + 2) < hexString.length) {
                    formatted += ' ';
                }
            }
            return formatted;
        }
        
        function renderGenericMessage(msg) {
            return `
                <table>
                    <tr><th>Field</th><th>Value</th></tr>
                    ${Object.entries(msg).map(([key, value]) => {
                        if (key === 'timestamp' || key === 'report_type') return '';
                        if (typeof value === 'object') {
                            return `<tr><td>${key}</td><td>${JSON.stringify(value, null, 2)}</td></tr>`;
                        }
                        return `<tr><td>${key}</td><td>${value}</td></tr>`;
                    }).join('')}
                </table>
            `;
        }
        
        function formatTimestamp(ts) {
            if (!ts) return 'N/A';
            try {
                const date = new Date(ts);
                return date.toLocaleString();
            } catch {
                return ts;
            }
        }
        
        function refreshMessages() {
            fetchMessages();
        }
        
        function clearMessages() {
            if (confirm('Clear all messages? This cannot be undone.')) {
                messages = [];
                renderMessages();
            }
        }
        
        // Auto-refresh every 2 seconds
        setInterval(() => {
            if (autoRefresh) {
                fetchMessages();
            }
        }, 2000);
        
        // Initial load
        fetchMessages();
    </script>
</body>
</html>

